var app=function(){"use strict";function t(){}function n(t){return t()}function e(){return Object.create(null)}function s(t){t.forEach(n)}function a(t){return"function"==typeof t}function o(t,n){return t!=t?n==n:t!==n}function r(t,n,e,s){return t[1]&&s?function(t,n){for(const e in n)t[e]=n[e];return t}(e.ctx.slice(),t[1](s(n))):e.ctx}function i(t,n,e,s,a,o,i){const c=function(t,n,e,s){if(t[2]&&s){const a=t[2](s(e));if(void 0===n.dirty)return a;if("object"==typeof a){const t=[],e=Math.max(n.dirty.length,a.length);for(let s=0;s<e;s+=1)t[s]=n.dirty[s]|a[s];return t}return n.dirty|a}return n.dirty}(n,s,a,o);if(c){const a=r(n,e,s,i);t.p(a,c)}}function c(t,n){t.appendChild(n)}function l(t,n,e){t.insertBefore(n,e||null)}function p(t){t.parentNode.removeChild(t)}function u(t){return document.createElement(t)}function d(t){return document.createTextNode(t)}function f(){return d(" ")}function g(t,n,e){null==e?t.removeAttribute(n):t.getAttribute(n)!==e&&t.setAttribute(n,e)}function h(t,n,e){t.classList[e?"add":"remove"](n)}let m;function v(t){m=t}function k(){if(!m)throw new Error("Function called outside component initialization");return m}function b(){const t=k();return(n,e)=>{const s=t.$$.callbacks[n];if(s){const a=function(t,n){const e=document.createEvent("CustomEvent");return e.initCustomEvent(t,!1,!1,n),e}(n,e);s.slice().forEach((n=>{n.call(t,a)}))}}}const y=[],$=[],x=[],w=[],E=Promise.resolve();let I=!1;function M(){I||(I=!0,E.then(L))}function C(t){x.push(t)}let T=!1;const O=new Set;function L(){if(!T){T=!0;do{for(let t=0;t<y.length;t+=1){const n=y[t];v(n),_(n.$$)}for(v(null),y.length=0;$.length;)$.pop()();for(let t=0;t<x.length;t+=1){const n=x[t];O.has(n)||(O.add(n),n())}x.length=0}while(y.length);for(;w.length;)w.pop()();I=!1,T=!1,O.clear()}}function _(t){if(null!==t.fragment){t.update(),s(t.before_update);const n=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,n),t.after_update.forEach(C)}}const H=new Set;function A(t,n){t&&t.i&&(H.delete(t),t.i(n))}function P(t,n,e,s){if(t&&t.o){if(H.has(t))return;H.add(t),undefined.c.push((()=>{H.delete(t),s&&(e&&t.d(1),s())})),t.o(n)}}function S(t,e,o,r){const{fragment:i,on_mount:c,on_destroy:l,after_update:p}=t.$$;i&&i.m(e,o),r||C((()=>{const e=c.map(n).filter(a);l?l.push(...e):s(e),t.$$.on_mount=[]})),p.forEach(C)}function j(t,n){const e=t.$$;null!==e.fragment&&(s(e.on_destroy),e.fragment&&e.fragment.d(n),e.on_destroy=e.fragment=null,e.ctx=[])}function q(n,a,o,r,i,c,l=[-1]){const u=m;v(n);const d=n.$$={fragment:null,ctx:null,props:c,update:t,not_equal:i,bound:e(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(u?u.$$.context:[]),callbacks:e(),dirty:l,skip_bound:!1};let f=!1;if(d.ctx=o?o(n,a.props||{},((t,e,...s)=>{const a=s.length?s[0]:e;return d.ctx&&i(d.ctx[t],d.ctx[t]=a)&&(!d.skip_bound&&d.bound[t]&&d.bound[t](a),f&&function(t,n){-1===t.$$.dirty[0]&&(y.push(t),M(),t.$$.dirty.fill(0)),t.$$.dirty[n/31|0]|=1<<n%31}(n,t)),e})):[],d.update(),f=!0,s(d.before_update),d.fragment=!!r&&r(d.ctx),a.target){if(a.hydrate){const t=function(t){return Array.from(t.childNodes)}(a.target);d.fragment&&d.fragment.l(t),t.forEach(p)}else d.fragment&&d.fragment.c();a.intro&&A(n.$$.fragment),S(n,a.target,a.anchor,a.customElement),L()}v(u)}class D{$destroy(){j(this,1),this.$destroy=t}$on(t,n){const e=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return e.push(n),()=>{const t=e.indexOf(n);-1!==t&&e.splice(t,1)}}$set(t){var n;this.$$set&&(n=t,0!==Object.keys(n).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const N=t=>({intersecting:2&t,entry:1&t,observer:4&t}),U=t=>({intersecting:t[1],entry:t[0],observer:t[2]});function z(t){let n;const e=t[9].default,s=function(t,n,e,s){if(t){const a=r(t,n,e,s);return t[0](a)}}(e,t,t[8],U);return{c(){s&&s.c()},m(t,e){s&&s.m(t,e),n=!0},p(t,[n]){s&&s.p&&263&n&&i(s,e,t,t[8],n,N,U)},i(t){n||(A(s,t),n=!0)},o(t){P(s,t),n=!1},d(t){s&&s.d(t)}}}function B(t,n,e){let{$$slots:s={},$$scope:a}=n,{element:o=null}=n,{once:r=!1}=n,{root:i=null}=n,{rootMargin:c="0px"}=n,{threshold:l=0}=n,{entry:p=null}=n,{intersecting:u=!1}=n,{observer:d=null}=n;const f=b();let g=null;var h;return h=async()=>{null!==p&&(f("observe",p),p.isIntersecting&&(f("intersect",p),r&&d.unobserve(p.target))),await(M(),E),null!==o&&o!==g&&(d.observe(o),null!==g&&d.unobserve(g),g=o)},k().$$.after_update.push(h),function(t){k().$$.on_destroy.push(t)}((()=>{d&&d.disconnect()})),t.$$set=t=>{"element"in t&&e(3,o=t.element),"once"in t&&e(4,r=t.once),"root"in t&&e(5,i=t.root),"rootMargin"in t&&e(6,c=t.rootMargin),"threshold"in t&&e(7,l=t.threshold),"entry"in t&&e(0,p=t.entry),"intersecting"in t&&e(1,u=t.intersecting),"observer"in t&&e(2,d=t.observer),"$$scope"in t&&e(8,a=t.$$scope)},t.$$.update=()=>{224&t.$$.dirty&&"undefined"!=typeof window&&e(2,d=new IntersectionObserver((t=>{t.forEach((t=>{e(0,p=t),e(1,u=t.isIntersecting)}))}),{root:i,rootMargin:c,threshold:l}))},[p,u,d,o,r,i,c,l,a,s]}class G extends D{constructor(t){super(),q(this,t,B,z,o,{element:3,once:4,root:5,rootMargin:6,threshold:7,entry:0,intersecting:1,observer:2})}}function W(n){let e,s;return{c(){e=u("div"),e.textContent="Hello world",s=f()},m(t,a){l(t,e,a),n[2](e),l(t,s,a)},p:t,d(t){t&&p(e),n[2](null),t&&p(s)}}}function R(t){let n,e,s,a,o,r,i,m,v,k,b,y,x,E,I,M,C,T,O,L,_,H,q,D,N,U,z,B,R,F,V,J,K,Q,X,Y,Z,tt,nt,et,st,at,ot,rt,it,ct,lt,pt,ut,dt,ft,gt,ht,mt,vt,kt,bt,yt,$t=t[1]?"Element is in view":"Element is not in view";function xt(n){t[3](n)}let wt={element:t[0],$$slots:{default:[W]},$$scope:{ctx:t}};return void 0!==t[1]&&(wt.intersecting=t[1]),z=new G({props:wt}),$.push((()=>function(t,n,e){const s=t.$$.props[n];void 0!==s&&(t.$$.bound[s]=e,e(t.$$.ctx[s]))}(z,"intersecting",xt))),{c(){var c;n=u("main"),e=u("h1"),e.textContent="svelte-intersection-observer",s=f(),a=u("p"),a.innerHTML='<a href="https://npmjs.com/package/svelte-intersection-observer"><img src="https://img.shields.io/npm/v/svelte-intersection-observer.svg?color=%23ff3e00&amp;style=for-the-badge" alt="NPM"/></a>',o=f(),r=u("blockquote"),r.innerHTML='<p>Detect if an element is in the viewport using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry">Intersection Observer API</a>.</p>',i=f(),m=u("p"),m.innerHTML='<a href="https://github.com/metonym/svelte-intersection-observer.git">GitHub repo</a>',v=f(),k=u("p"),k.innerHTML='Try it in the <a href="https://svelte.dev/repl/8cd2327a580c4f429c71f7df999bd51d">Svelte REPL</a>.',b=f(),y=u("p"),y.innerHTML="<strong>Table of Contents</strong>",x=u("ul"),x.innerHTML='<li><a href="#install">Install</a></li> \n<li><a href="#usage">Usage</a></li> \n<ul><li><a href="#basic">Basic</a></li> \n<li><a href="#on%3Aintersect-event">on:intersect event</a></li> \n</ul><li><a href="#api">API</a></li> \n<ul><li><a href="#props">Props</a></li> \n<li><a href="#dispatched-events">Dispatched events</a></li> \n</ul><li><a href="#typescript-support">TypeScript support</a></li> \n<li><a href="#changelog">Changelog</a></li> \n<li><a href="#license">License</a></li>',E=f(),I=u("h2"),I.textContent="Install",M=f(),C=u("pre"),T=f(),O=u("h2"),O.textContent="Usage",L=f(),_=u("h3"),_.textContent="Basic",H=f(),q=u("div"),D=u("header"),N=d($t),U=f(),(c=z.$$.fragment)&&c.c(),R=u("pre"),F=f(),V=u("h3"),V.textContent="on:intersect event",J=f(),K=u("p"),K.textContent="The “intersect” event is dispatched only if the observed element is intersecting the viewport.",Q=f(),X=u("pre"),Y=f(),Z=u("h2"),Z.textContent="API",tt=f(),nt=u("h3"),nt.textContent="Props",et=f(),st=u("table"),st.innerHTML='<thead><tr><th style="text-align:left">Prop name</th> \n<th style="text-align:left">Description</th> \n<th style="text-align:left">Value</th></tr></thead> \n<tbody><tr><td style="text-align:left">element</td> \n<td style="text-align:left">Element observed for intersection</td> \n<td style="text-align:left"><code>HTMLElement</code></td></tr> \n<tr><td style="text-align:left">root</td> \n<td style="text-align:left">Containing element</td> \n<td style="text-align:left"><code>null</code> or <code>HTMLElement</code> (default: <code>null</code>)</td></tr> \n<tr><td style="text-align:left">rootMargin</td> \n<td style="text-align:left">Margin offset of the containing element</td> \n<td style="text-align:left"><code>string</code> (default: <code>&quot;0px&quot;</code>)</td></tr> \n<tr><td style="text-align:left">threshold</td> \n<td style="text-align:left">Percentage of element visibility to trigger an event</td> \n<td style="text-align:left"><code>number</code> between 0 and 1 (default: <code>0</code>)</td></tr> \n<tr><td style="text-align:left">entry</td> \n<td style="text-align:left">Observed element metadata</td> \n<td style="text-align:left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserverEntry</code></a></td></tr> \n<tr><td style="text-align:left">once</td> \n<td style="text-align:left">If <code>true</code>, the observed element will be unobserved upon intersect</td> \n<td style="text-align:left"><code>boolean</code> (default: <code>false</code>)</td></tr> \n<tr><td style="text-align:left">intersecting</td> \n<td style="text-align:left"><code>true</code> if the observed element is intersecting the viewport</td> \n<td style="text-align:left"><code>boolean</code> (default: <code>false</code>)</td></tr> \n<tr><td style="text-align:left">observer</td> \n<td style="text-align:left">IntersectionObserver instance</td> \n<td style="text-align:left"><a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver"><code>IntersectionObserver</code></a></td></tr></tbody>',at=f(),ot=u("h3"),ot.textContent="Dispatched events",rt=f(),it=u("ul"),it.innerHTML="<li><strong>on:observe</strong>: fired when an intersection change occurs (type <code>IntersectionObserverEntry</code>)</li> \n<li><strong>on:intersect</strong>: fired when an intersection change occurs and the element is intersecting (type <code>IntersectionObserverEntry</code>)</li>",ct=f(),lt=u("h2"),lt.textContent="TypeScript support",pt=f(),ut=u("p"),ut.textContent="Svelte version 3.31.0 or greater is required to use this module with TypeScript.",dt=f(),ft=u("h2"),ft.textContent="Changelog",gt=f(),ht=u("p"),ht.innerHTML='<a href="https://github.com/metonym/svelte-intersection-observer/tree/master/CHANGELOG.md">Changelog</a>',mt=f(),vt=u("h2"),vt.textContent="License",kt=f(),bt=u("p"),bt.innerHTML='<a href="https://github.com/metonym/svelte-intersection-observer/tree/master/LICENSE">MIT</a>',g(e,"id","svelte-intersection-observer"),g(I,"id","install"),g(C,"class","language-bash"),g(O,"id","usage"),g(_,"id","basic"),h(D,"intersecting",t[1]),g(q,"class","code-fence"),g(R,"class","language-svelte"),g(R,"data-svelte",""),g(V,"id","on%3Aintersect-event"),g(X,"class","language-html"),g(Z,"id","api"),g(nt,"id","props"),g(ot,"id","dispatched-events"),g(lt,"id","typescript-support"),g(ft,"id","changelog"),g(vt,"id","license"),g(n,"class","markdown-body")},m(t,p){l(t,n,p),c(n,e),c(n,s),c(n,a),c(n,o),c(n,r),c(n,i),c(n,m),c(n,v),c(n,k),c(n,b),c(n,y),c(n,x),c(n,E),c(n,I),c(n,M),c(n,C),C.innerHTML='<span class="token function">yarn</span> <span class="token function">add</span> -D svelte-intersection-observer\n<span class="token comment"># OR</span>\n<span class="token function">npm</span> i -D svelte-intersection-observer\n',c(n,T),c(n,O),c(n,L),c(n,_),c(n,H),c(n,q),c(q,D),c(D,N),c(q,U),S(z,q,null),c(n,R),R.innerHTML='<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">import</span> IntersectionObserver <span class="token keyword">from</span> <span class="token string">"svelte-intersection-observer"</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">let</span> element<span class="token punctuation">;</span>\n  <span class="token keyword">let</span> intersecting<span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span> <span class="token attr-name"><span class="token namespace">class:</span>intersecting</span><span class="token punctuation">></span></span>\n  <span class="token language-javascript"><span class="token punctuation">{</span>intersecting <span class="token operator">?</span> <span class="token string">"Element is in view"</span> <span class="token operator">:</span> <span class="token string">"Element is not in view"</span><span class="token punctuation">}</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IntersectionObserver</span> <span class="token language-javascript"><span class="token punctuation">{</span>element<span class="token punctuation">}</span></span> <span class="token attr-name"><span class="token namespace">bind:</span>intersecting</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">bind:</span>this=</span><span class="token language-javascript"><span class="token punctuation">{</span>element<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>Hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>IntersectionObserver</span><span class="token punctuation">></span></span>\n',c(n,F),c(n,V),c(n,J),c(n,K),c(n,Q),c(n,X),X.innerHTML='<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IntersectionObserver</span>\n  <span class="token attr-name">{element}</span>\n  <span class="token attr-name"><span class="token namespace">on:</span>intersect</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{(e) => {\n    console.log(e.detail); // IntersectionObserverEntry\n  }}<span class="token punctuation">"</span></span>\n<span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">bind:</span>this</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{element}</span><span class="token punctuation">></span></span>Hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>IntersectionObserver</span><span class="token punctuation">></span></span>\n',c(n,Y),c(n,Z),c(n,tt),c(n,nt),c(n,et),c(n,st),c(n,at),c(n,ot),c(n,rt),c(n,it),c(n,ct),c(n,lt),c(n,pt),c(n,ut),c(n,dt),c(n,ft),c(n,gt),c(n,ht),c(n,mt),c(n,vt),c(n,kt),c(n,bt),yt=!0},p(t,[n]){(!yt||2&n)&&$t!==($t=t[1]?"Element is in view":"Element is not in view")&&function(t,n){n=""+n,t.wholeText!==n&&(t.data=n)}(N,$t),2&n&&h(D,"intersecting",t[1]);const e={};var s;1&n&&(e.element=t[0]),17&n&&(e.$$scope={dirty:n,ctx:t}),!B&&2&n&&(B=!0,e.intersecting=t[1],s=()=>B=!1,w.push(s)),z.$set(e)},i(t){yt||(A(z.$$.fragment,t),yt=!0)},o(t){P(z.$$.fragment,t),yt=!1},d(t){t&&p(n),j(z)}}}function F(t,n,e){let s,a;return[s,a,function(t){$[t?"unshift":"push"]((()=>{s=t,e(0,s)}))},function(t){a=t,e(1,a)}]}return new class extends D{constructor(t){super(),q(this,t,F,R,o,{})}}({target:document.body})}();
